// Code generated by re2c 2.2 on Mon Nov 29 18:27:00 2021, DO NOT EDIT.
package lexer

import "bytes"

func (s *lexerState) lex() (Token, error) {
	for {
		s.token = s.cursor

		{
			var yych byte
			yyaccept := 0
			yych = s.text[s.cursor]
			if yych <= '/' {
				if yych <= '!' {
					if yych <= '\n' {
						if yych <= 0x00 {
							goto yy2
						}
						if yych <= 0x08 {
							goto yy4
						}
						if yych <= '\t' {
							goto yy6
						}
						goto yy9
					} else {
						if yych <= '\r' {
							if yych <= '\f' {
								goto yy4
							}
							goto yy11
						} else {
							if yych == ' ' {
								goto yy6
							}
							goto yy4
						}
					}
				} else {
					if yych <= ')' {
						if yych <= '"' {
							goto yy12
						}
						if yych <= '\'' {
							goto yy4
						}
						if yych <= '(' {
							goto yy14
						}
						goto yy16
					} else {
						if yych <= ',' {
							if yych <= '+' {
								goto yy4
							}
							goto yy18
						} else {
							if yych == '.' {
								goto yy20
							}
							goto yy4
						}
					}
				}
			} else {
				if yych <= '^' {
					if yych <= ';' {
						if yych <= '0' {
							goto yy21
						}
						if yych <= '9' {
							goto yy22
						}
						if yych <= ':' {
							goto yy25
						}
						goto yy27
					} else {
						if yych <= '=' {
							if yych <= '<' {
								goto yy4
							}
							goto yy29
						} else {
							if yych <= '@' {
								goto yy4
							}
							if yych <= 'Z' {
								goto yy31
							}
							goto yy4
						}
					}
				} else {
					if yych <= 'r' {
						if yych == '`' {
							goto yy4
						}
						if yych <= 'q' {
							goto yy31
						}
						goto yy34
					} else {
						if yych <= '{' {
							if yych <= 'z' {
								goto yy31
							}
							goto yy35
						} else {
							if yych == '}' {
								goto yy37
							}
							goto yy4
						}
					}
				}
			}
		yy2:
			s.cursor += 1
			{
				return s.createToken(Eof), nil
			}
		yy4:
			s.cursor += 1
		yy5:
			{
				return Token{}, ErrBadToken
			}
		yy6:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych == '\t' {
				goto yy6
			}
			if yych == ' ' {
				goto yy6
			}
			{
				continue
			}
		yy9:
			s.cursor += 1
			{
				if s.lexEol() == Semicolon {
					s.cursor = s.token // Has the effect of "inserting" the semicolon in the input
					return s.createToken(Semicolon), nil
				} else {
					s.line += 1
					s.lineStart = s.cursor
					continue
				}
			}
		yy11:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych == '\n' {
				goto yy9
			}
			goto yy5
		yy12:
			s.cursor += 1
			{
				return s.lexString('"')
			}
		yy14:
			s.cursor += 1
			{
				return s.createToken(LParen), nil
			}
		yy16:
			s.cursor += 1
			{
				return s.createToken(RParen), nil
			}
		yy18:
			s.cursor += 1
			{
				return s.createToken(Comma), nil
			}
		yy20:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych <= '/' {
				goto yy5
			}
			if yych <= '9' {
				goto yy39
			}
			goto yy5
		yy21:
			yyaccept = 0
			s.cursor += 1
			s.marker = s.cursor
			yych = s.text[s.cursor]
			if yych <= '9' {
				if yych == '.' {
					goto yy39
				}
				if yych <= '/' {
					goto yy5
				}
				goto yy42
			} else {
				if yych <= 'E' {
					if yych <= 'D' {
						goto yy5
					}
					goto yy45
				} else {
					if yych == 'e' {
						goto yy45
					}
					goto yy5
				}
			}
		yy22:
			yyaccept = 1
			s.cursor += 1
			s.marker = s.cursor
			yych = s.text[s.cursor]
			if yych <= '9' {
				if yych == '.' {
					goto yy39
				}
				if yych >= '0' {
					goto yy22
				}
			} else {
				if yych <= 'E' {
					if yych >= 'E' {
						goto yy45
					}
				} else {
					if yych == 'e' {
						goto yy45
					}
				}
			}
		yy24:
			{
				return s.createToken(Integer), nil
			}
		yy25:
			s.cursor += 1
			{
				return s.createToken(Colon), nil
			}
		yy27:
			s.cursor += 1
			{
				return s.createToken(Semicolon), nil
			}
		yy29:
			s.cursor += 1
			{
				return s.createToken(Equals), nil
			}
		yy31:
			s.cursor += 1
			yych = s.text[s.cursor]
		yy32:
			if yych <= 'Z' {
				if yych <= '/' {
					goto yy33
				}
				if yych <= '9' {
					goto yy31
				}
				if yych >= 'A' {
					goto yy31
				}
			} else {
				if yych <= '_' {
					if yych >= '_' {
						goto yy31
					}
				} else {
					if yych <= '`' {
						goto yy33
					}
					if yych <= 'z' {
						goto yy31
					}
				}
			}
		yy33:
			{
				return s.createToken(Ident), nil
			}
		yy34:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych == 'e' {
				goto yy46
			}
			goto yy32
		yy35:
			s.cursor += 1
			{
				return s.createToken(LCurlyBrack), nil
			}
		yy37:
			s.cursor += 1
			{
				return s.createToken(RCurlyBrack), nil
			}
		yy39:
			yyaccept = 2
			s.cursor += 1
			s.marker = s.cursor
			yych = s.text[s.cursor]
			if yych <= 'D' {
				if yych <= '/' {
					goto yy41
				}
				if yych <= '9' {
					goto yy39
				}
			} else {
				if yych <= 'E' {
					goto yy45
				}
				if yych == 'e' {
					goto yy45
				}
			}
		yy41:
			{
				return s.createToken(Float), nil
			}
		yy42:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych <= '9' {
				if yych == '.' {
					goto yy39
				}
				if yych >= '0' {
					goto yy42
				}
			} else {
				if yych <= 'E' {
					if yych >= 'E' {
						goto yy45
					}
				} else {
					if yych == 'e' {
						goto yy45
					}
				}
			}
		yy44:
			s.cursor = s.marker
			if yyaccept <= 1 {
				if yyaccept == 0 {
					goto yy5
				} else {
					goto yy24
				}
			} else {
				goto yy41
			}
		yy45:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych <= ',' {
				if yych == '+' {
					goto yy47
				}
				goto yy44
			} else {
				if yych <= '-' {
					goto yy47
				}
				if yych <= '/' {
					goto yy44
				}
				if yych <= '9' {
					goto yy48
				}
				goto yy44
			}
		yy46:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych == 't' {
				goto yy50
			}
			goto yy32
		yy47:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych <= '/' {
				goto yy44
			}
			if yych >= ':' {
				goto yy44
			}
		yy48:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych <= '/' {
				goto yy41
			}
			if yych <= '9' {
				goto yy48
			}
			goto yy41
		yy50:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych != 'u' {
				goto yy32
			}
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych != 'r' {
				goto yy32
			}
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych != 'n' {
				goto yy32
			}
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych <= 'Z' {
				if yych <= '/' {
					goto yy54
				}
				if yych <= '9' {
					goto yy31
				}
				if yych >= 'A' {
					goto yy31
				}
			} else {
				if yych <= '_' {
					if yych >= '_' {
						goto yy31
					}
				} else {
					if yych <= '`' {
						goto yy54
					}
					if yych <= 'z' {
						goto yy31
					}
				}
			}
		yy54:
			{
				return s.createToken(Return), nil
			}
		}

	}
}

func (s *lexerState) lexString(quote byte) (Token, error) {
	var buf bytes.Buffer
	for {
		var u byte

		{
			var yych byte
			yych = s.text[s.cursor]
			if yych == '\n' {
				goto yy59
			}
			if yych == '\\' {
				goto yy61
			}
			s.cursor += 1
			{
				u = yych
				if u == quote {
					tok := s.createToken(String)
					tok.Value = string(buf.Bytes())
					return tok, nil
				}
				buf.WriteByte(u)
				continue
			}
		yy59:
			s.cursor += 1
		yy60:
			{
				return Token{}, ErrInvalidString
			}
		yy61:
			s.cursor += 1
			yych = s.text[s.cursor]
			if yych <= 'b' {
				if yych <= '>' {
					if yych <= '"' {
						if yych <= '!' {
							goto yy60
						}
					} else {
						if yych == '\'' {
							goto yy64
						}
						goto yy60
					}
				} else {
					if yych <= '\\' {
						if yych <= '?' {
							goto yy66
						}
						if yych <= '[' {
							goto yy60
						}
						goto yy68
					} else {
						if yych <= '`' {
							goto yy60
						}
						if yych <= 'a' {
							goto yy70
						}
						goto yy72
					}
				}
			} else {
				if yych <= 'q' {
					if yych <= 'f' {
						if yych <= 'e' {
							goto yy60
						}
						goto yy74
					} else {
						if yych == 'n' {
							goto yy76
						}
						goto yy60
					}
				} else {
					if yych <= 't' {
						if yych <= 'r' {
							goto yy78
						}
						if yych <= 's' {
							goto yy60
						}
						goto yy80
					} else {
						if yych == 'v' {
							goto yy82
						}
						goto yy60
					}
				}
			}
			s.cursor += 1
			{
				buf.WriteByte('"')
				continue
			}
		yy64:
			s.cursor += 1
			{
				buf.WriteByte('\'')
				continue
			}
		yy66:
			s.cursor += 1
			{
				buf.WriteByte('?')
				continue
			}
		yy68:
			s.cursor += 1
			{
				buf.WriteByte('\\')
				continue
			}
		yy70:
			s.cursor += 1
			{
				buf.WriteByte('\a')
				continue
			}
		yy72:
			s.cursor += 1
			{
				buf.WriteByte('\b')
				continue
			}
		yy74:
			s.cursor += 1
			{
				buf.WriteByte('\f')
				continue
			}
		yy76:
			s.cursor += 1
			{
				buf.WriteByte('\n')
				continue
			}
		yy78:
			s.cursor += 1
			{
				buf.WriteByte('\r')
				continue
			}
		yy80:
			s.cursor += 1
			{
				buf.WriteByte('\t')
				continue
			}
		yy82:
			s.cursor += 1
			{
				buf.WriteByte('\v')
				continue
			}
		}

	}
}
